c-----------------------------------------------------------------------
      subroutine area_average(phi,loc,coord,norm,phia)
C
C     Compute area average of phi() on the
C     plane normal to norm() with intercept coord = loc
C
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i,i0,i1,j,j0,j1,k,k0,k1
      real phi(1),wrt(1),loc,coord(1),norm(3),phia
      real fnorm(3),dp,a1,phia1

      loc=get_nearest_face(loc,coord,norm)

      phia=0.0
      phia1=0.0
      do ielem=1,nelv
        do iside=1,ndim*2
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
          i=(i0+i1)/2  !just use the point in the middle of the face
          j=(j0+j1)/2
          k=(k0+k1)/2
          ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
          if(abs(coord(ipoint)-loc).lt.1.0d-8)then
            call get_face_norm(ielem,iside,fnorm)
            dp=fnorm(1)*norm(1)+fnorm(2)*norm(2)
            if(if3d) dp=dp+fnorm(3)*norm(3)
            if(abs(1.0d0-dp).lt.1.0d-8) then
              do i=i0,i1
              do j=j0,j1
              do k=k0,k1
                ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
                if    ((iside.eq.1).or.(iside.eq.3)) then
                  a1=area(i,k,iside,ielem)
                elseif((iside.eq.2).or.(iside.eq.4)) then
                  a1=area(j,k,iside,ielem)
                else
                  a1=area(i,j,iside,ielem)
                endif
                phia=phia+phi(ipoint)*a1
                phia1=phia1+a1
              enddo
              enddo
              enddo
            endif
          endif
        enddo
      enddo

      phia=glsum(phia,1)
      phia1=glsum(phia1,1)
      phia=phia/phia1

      return
      end
C-----------------------------------------------------------------------
      subroutine count_boundaries
      include 'SIZE'
      include 'TOTAL'

      integer lxyz,ielem,iside,n
      parameter(lxyz=lx1*ly1*lz1)
      character*3 uid(ldimt+1)
      integer wcount(ldimt+1),symcount(ldimt+1),ocount(ldimt+1)
      integer tcount(ldimt+1),fcount(ldimt+1),axicount(ldimt+1)
      integer inscount(ldimt+1),pcount(ldimt+1),othcount(ldimt+1)
      integer vcount(ldimt+1),trcount(ldimt+1),ukncount(ldimt+1)
      integer vreacount(ldimt+1),treacount(ldimt+1)

      call izero(wcount,ldimt+1)
      call izero(trcount,ldimt+1)
      call izero(vcount,ldimt+1)
      call izero(vreacount,ldimt+1)
      call izero(symcount,ldimt+1)
      call izero(ocount,ldimt+1)
      call izero(tcount,ldimt+1)
      call izero(treacount,ldimt+1)
      call izero(axicount,ldimt+1)
      call izero(inscount,ldimt+1)
      call izero(fcount,ldimt+1)
      call izero(pcount,ldimt+1)
      call izero(othcount,ldimt+1)
      call izero(ukncount,ldimt+1)

      do ifld=1,nfield
        do ielem=1,nelv
        do iside=1,2*ldim
          if(cbc(iside,ielem,ifld).eq.'W  ')then
            wcount(ifld)=wcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'shl')then
            trcount(ifld)=trcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'v  ')then
            vcount(ifld)=vcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'V  ')then
            vreacount(ifld)=vreacount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'t  ')then
            tcount(ifld)=tcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'T  ')then
            treacount(ifld)=treacount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'O  ')then
            ocount(ifld)=ocount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'P  ')then
            pcount(ifld)=pcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'f  ')then 
            fcount(ifld)=fcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'I  ')then
            inscount(ifld)=inscount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'SYM')then
            symcount(ifld)=symcount(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'A  ')then
            axicount(ifld)=axicount(ifld)+1
          elseif(cbc(iside,ielem,ifld).ne.'E  ')then
            if(ukncount(ifld).eq.0) then  !handle one unknown BC
              uid(ifld)=cbc(iside,ielem,ifld)
              ukncount(ifld)=1
            elseif(cbc(iside,ielem,ifld).eq.uid(ifld)) then
              ukncount(ifld)=ukncount(ifld)+1
            else
              othcount(ifld)=othcount(ifld)+1 !multiple unknown BCs 
            endif
          endif
        enddo
        enddo
        wcount(ifld)=iglsum(wcount(ifld),1)
        trcount(ifld)=iglsum(trcount(ifld),1)
        vcount(ifld)=iglsum(vcount(ifld),1)
        vreacount(ifld)=iglsum(vreacount(ifld),1)
        tcount(ifld)=iglsum(tcount(ifld),1)
        treacount(ifld)=iglsum(treacount(ifld),1)
        ocount(ifld)=iglsum(ocount(ifld),1)
        pcount(ifld)=iglsum(pcount(ifld),1)
        fcount(ifld)=iglsum(fcount(ifld),1)
        inscount(ifld)=iglsum(inscount(ifld),1)
        symcount(ifld)=iglsum(symcount(ifld),1)
        axicount(ifld)=iglsum(axicount(ifld),1)
        othcount(ifld)=iglsum(othcount(ifld),1)
        ukncount(ifld)=iglsum(ukncount(ifld),1)
      enddo

      if(nid.eq.0) then
        write(*,*)
        write(*,255) 'Found the following Boundary Conditions'
        write(*,*)
        do ifld=1,nfield
          write(*,254) 'for field',ifld,':'
          if(wcount(ifld).gt.0)write(*,256)'Wall',wcount(ifld)
          if(trcount(ifld).gt.0)write(*,256)'Traction',trcount(ifld)
          if(vcount(ifld).gt.0)write(*,256)'Velocity',vcount(ifld)
          if(vreacount(ifld).gt.0)write(*,256)'Velocity (REA)',
     &                                                   vreacount(ifld)
          if(tcount(ifld).gt.0)write(*,256)'Dirichlet',tcount(ifld)
          if(treacount(ifld).gt.0)write(*,256)'Dirichlet (REA)',
     &                                                   treacount(ifld)
          if(pcount(ifld).gt.0)write(*,256)'Periodic',pcount(ifld)
          if(fcount(ifld).gt.0)write(*,256)'Flux',fcount(ifld)
          if(ocount(ifld).gt.0)write(*,256)'Outlet',ocount(ifld)
          if(inscount(ifld).gt.0)write(*,256)'Insulated',inscount(ifld)
          if(symcount(ifld).gt.0)write(*,256)'Symmetry',symcount(ifld)
          if(axicount(ifld).gt.0)write(*,256)
     &                                     'Axisymmetric',axicount(ifld)
          if(ukncount(ifld).gt.0)write(*,257)uid(ifld),ukncount(ifld)
          if(othcount(ifld).gt.0)write(*,256)'Other',othcount(ifld)
          write(*,*)
        enddo
      endif

 254  format(5x,a,i2,a)
 255  format(2x,a)
 256  format(2x,a16,1x,i6)
 257  format(2x,'Unknown boundary of type: ',a,1x,i6)

      return
      end
C-----------------------------------------------------------------------
      subroutine div_check(phi)

      real phi(1)

      if(phi(1).ne.phi(1)) call exitt
      return
      end
C-----------------------------------------------------------------------
      real function get_bforce(utarg,bias,u,K_p,K_i)

      include 'SIZE'
      include 'TOTAL'

      integer n
      real utarg,ubar,error,ierror,derror,perror,bias
      real K_p,K_i,K_d
      real u(1)

      data ierror /0.0/
      save ierror,perror

      K_d=0.0

      n=lx1*ly1*lz1*nelv
      ubar=glsc2(u,bm1,n)/volvm1
      error=1.0-ubar/utarg
      ierror=ierror+error*dt
      derror=(error-perror)/dt
      if(istep.lt.2) then
        force=bias
      else
        force=bias+(K_p*error+K_i*ierror+K_d*derror)*utarg/dt
      endif
      perror=error

      if(nid.eq.0) then
        write(*,256) '  Body Force Set: ',force
        write(*,256) '           Error: ',error
        write(*,*)
      endif
 256  format(4x,a,es15.5)

      get_bforce=force

      return
      end
c-----------------------------------------------------------------------
      subroutine get_face_norm(ielem,iside,norm)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i0,i1,j0,j1,k0,k1,i,j,k
      real norm(3)

      call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
      i=(i0+i1)/2
      j=(j0+j1)/2
      k=(k0+k1)/2
      if    ((iside.eq.1).or.(iside.eq.3))then
        norm(1)=unx(i,k,iside,ielem)
        norm(2)=uny(i,k,iside,ielem)
        norm(3)=unz(i,k,iside,ielem)
      elseif((iside.eq.2).or.(iside.eq.4))then
        norm(1)=unx(j,k,iside,ielem)
        norm(2)=uny(j,k,iside,ielem)
        norm(3)=unz(j,k,iside,ielem)
      else
        norm(1)=unx(i,j,iside,ielem)
        norm(2)=uny(i,j,iside,ielem)
        norm(3)=unz(i,j,iside,ielem)
      endif
      return
      end
C-----------------------------------------------------------------------
      subroutine get_limits(phi,phimin,phimax,phiave,dphi,phip,rmsphi)
      include 'SIZE'
      include 'TOTAL'

      integer lxyze
      parameter(lxyze=lx1*ly1*lz1*lelv)

      real phi(1),phip(1),phimin,phimax,phiave,dphi,rmsphi,vol
      integer i,n,ntot

      n=nx1*ny1*nz1*nelv
      ntot=iglsum(n,1)

      rmsphi=0.0
      dphi=0.0
      vol=glsum(bm1,n)
      if(istep.ge.1) then
        do i=1,n
          dphi=max(dphi,abs(phip(i)-phi(i)))
          rmsphi=rmsphi+(phip(i)-phi(i))**2
        enddo
        rmsphi=glsum(rmsphi,1)
        rmsphi=sqrt(rmsphi/DBLE(ntot))/dt
      endif
      dphi=glmax(dphi,1)
      dphi=dphi/dt

      phimin=glmin(phi,n)
      phimax=glmax(phi,n)
      phiave=glsc2(phi,bm1,n)/vol

      return
      end
c-----------------------------------------------------------------------
      real function get_nearest(loc,coord)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ipoint,ierr
      real loc,coord(1),ds(2),dsg(2)

      ds(1)=1.0d30
      do ipoint=1,lx1*ly1*lz1*nelv
        if(abs(coord(ipoint)-loc).lt.ds(1)) then
          ds(1)=abs(coord(ipoint)-loc)
          ds(2)=coord(ipoint)
        endif
      enddo
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      get_nearest=dsg(2)
      return
      end
c-----------------------------------------------------------------------
      subroutine get_point3d(loc1,loc2,loc3,ix,iy,iz,eg)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ipoint,ierr,dsi,ix,iy,iz,ie,eg,jx,jy,jz,je
      real loc1,loc2,loc3,ds(2),dsg(2),dist(2)

      dist(2)=1.0d30
      do je=1,nelv
      do jz=1,lz1
      do jy=1,ly1
      do jx=1,lx1
        dist(1)=sqrt((loc1-xm1(jx,jy,jz,je))**2
     &           +(loc2-ym1(jx,jy,jz,je))**2+(loc3-zm1(jx,jy,jz,je))**2)
        if(dist(1).lt.dist(2)) then
          dist(2)=dist(1)
          ix=jx
          iy=jy
          iz=jz
          ie=je
        endif
      enddo
      enddo
      enddo
      enddo

      eg=lglel(ie)

      ds(1)=dist(2)

      ds(2)=dble(ix)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      ix=int(dsg(2))

      ds(2)=dble(iy)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      iy=int(dsg(2))

      ds(2)=dble(iz)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      iz=int(dsg(2))

      ds(2)=dble(eg)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      eg=int(dsg(2))

      return
      end
c-----------------------------------------------------------------------
      real function get_nearest_face(loc,coord,norm)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i0,i1,j0,j1,k0,k1,i,j,k,ierr
      real loc,coord(1),ds(2),dsg(2),norm(3),fnorm(3),dp

      ds(1)=1.0d30
      do ielem=1,nelv
        do iside=1,ldim*2
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
          i=(i0+i1)/2
          j=(j0+j1)/2
          k=(k0+k1)/2
          ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+lx1*ly1*lz1*(ielem-1)
          call get_face_norm(ielem,iside,fnorm)
          dp=fnorm(1)*norm(1)+fnorm(2)*norm(2)
          if(if3d) dp=dp+fnorm(3)*norm(3)
          if((1.0d0-abs(dp)).lt.1.0d-8)then
            if(abs(coord(ipoint)-loc).lt.ds(1)) then
              ds(1)=abs(coord(ipoint)-loc)
              ds(2)=coord(ipoint)
            endif
          endif
        enddo
      enddo
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      get_nearest_face=dsg(2)
      return
      end
C-----------------------------------------------------------------------
      subroutine max_y_p(wd)
      include 'SIZE'
      include 'TOTAL'

      real wd(nx1,ny1,nz1,nelv)
      integer ielem,iside,i,i0,i1,j,j0,j1,k,k0,k1
      real dwmax

      dwmax=-1.0d30
      do ielem=1,nelv
        do iside=1,6
          if(cbc(iside,ielem,1).eq.'W  ') then
            i0=1
            j0=1
            k0=1
            i1=nx1
            j1=ny1
            k1=nz1
            if(iside.eq.1) then
              j0=2
              j1=2
            elseif(iside.eq.2) then
              i0=nx1-1
              i1=nx1-1
            elseif(iside.eq.3) then
              j0=ny1-1
              j1=ny1-1
            elseif(iside.eq.4) then
              i0=2
              i1=2
            elseif(iside.eq.5) then
              k0=2
              k1=2
            elseif(iside.eq.6) then
              k0=nz1-1
              k1=nz1-1
            endif
            do i=i0,i1
            do j=j0,j1
            do k=k0,k1
              dwmax=max(dwmax,wd(i,j,k,ielem))
            enddo
            enddo
            enddo
          endif
        enddo
      enddo
      dwmax=glmax(dwmax,1)
      if(nid.eq.0) then
        write(*,256) 'maximum y_p = ',dwmax
        write(*,*)
      endif
 256  format(2x,a,es15.5)

      return
      end
C-----------------------------------------------------------------------
      subroutine weighted_average(phi,wrt,loc,coord,norm,phia)
C
C     Compute planar averages of phi() weighted by wrt() on the
C     plane normal to norm() with intercept coord = loc
C
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i,i0,i1,j,j0,j1,k,k0,k1
      real phi(1),wrt(1),loc,coord(1),norm(3),phia
      real fnorm(3),dp,a1,phia1

      loc=get_nearest_face(loc,coord,norm)

      phia=0.0
      phia1=0.0
      do ielem=1,nelv
        do iside=1,ndim*2
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
          i=(i0+i1)/2  !just use the point in the middle of the face
          j=(j0+j1)/2
          k=(k0+k1)/2
          ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
          if(abs(coord(ipoint)-loc).lt.1.0d-8)then 
            call get_face_norm(ielem,iside,fnorm)
            dp=fnorm(1)*norm(1)+fnorm(2)*norm(2)
            if(if3d) dp=dp+fnorm(3)*norm(3)
            if(abs(1.0d0-dp).lt.1.0d-8) then
              do i=i0,i1
              do j=j0,j1
              do k=k0,k1
                ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
                if    ((iside.eq.1).or.(iside.eq.3)) then
                  a1=area(i,k,iside,ielem)
                elseif((iside.eq.2).or.(iside.eq.4)) then
                  a1=area(j,k,iside,ielem)
                else
                  a1=area(i,j,iside,ielem)
                endif
                phia=phia+phi(ipoint)*wrt(ipoint)*a1
                phia1=phia1+wrt(ipoint)*a1
              enddo
              enddo
              enddo
            endif
          endif
        enddo
      enddo

      phia=glsum(phia,1)
      phia1=glsum(phia1,1)
      phia=phia/phia1

      return
      end
C-----------------------------------------------------------------------
      subroutine planar_average_weighted(phia,phi,wrt,w1,w2)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'

      real phi(nx1*ny1,nz1,nelv),wrt(nx1*ny1,nz1,nelv),phia(nz1,nelz)
      real w1(nz1,nelz),w2(nz1,nelz) !work arrays

      integer e,eg,ez,melxy,nz,i,k
      real zz,aa

      melxy=nelx*nely !number of elements in the plane
      nz=nz1*nelz !number of z-slices

      if(melxy.lt.1)then
        if(nio.eq.0)write(*,256)'nelx*nely'
        return
      elseif(nelz.lt.1) then
        if(nio.eq.0)write(*,256)'nelz'
        return
      elseif(melxy.gt.lelx*lely) then
        if(nio.eq.0)write(*,257)'nelx*nely','lelx*lely'
        return
      elseif(nelz.gt.lelz) then
        if(nio.eq.0)write(*,257)'nelz','lelz'
        return
      endif

 256  format(5x,'ERROR: ',a,' must be at least 1!')
 257  format(5x,'ERROR: ',a,' must be less than ',a,'!')

      call rzero(phia,nz)
      call rzero(w1,nz)

      do e=1,nelt
        eg=lglel(e)
        ez=1+(eg-1)/melxy !z-slice id
        do k=1,nz1
        do i=1,nx1*ny1
          zz=(1.0-zgm1(k,3))/2.0
          aa=zz*area(i,1,5,e)+(1.0-zz)*area(i,1,6,e)
          w1(k,ez)=w1(k,ez)+aa*wrt(i,k,e)
          phia(k,ez)=phia(k,ez)+aa*wrt(i,k,e)*phi(i,k,e)
        enddo
        enddo
      enddo

      call gop(phia,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
      call invcol2(phia,w1,nz)

      return
      end
C-----------------------------------------------------------------------
      subroutine y_p_limits(wd,dens,visc,ypmin,ypmax,ypave)
      include 'SIZE'
      include 'TOTAL'

      integer lxyz,lxyze
      parameter(lxyz=lx1*ly1*lz1,lxyze=lxyz*lelv)
      integer e,i,i0,i1,j,j0,j1,k,k0,k1,iw,jw,kw,i2
      integer ipoint,wpoint,nyp
      real gradu(lxyze,3,3),dens(1),visc(1),wd(1)
      real tau(3),norm(3),rho,mu,vsca,tauw,yp,utau

      ypmin=1.0d30
      ypmax=-1.0d30
      ypave=0.0
      nyp=0

      call gradm1(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),vx)
      call gradm1(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),vy)
      call gradm1(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),vz)

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),bm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),bm1)
      call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),bm1)

      call opdssum(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3))
      call opdssum(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3))
      call opdssum(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3))

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),binvm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),binvm1)
      call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),binvm1)

      do e=1,nelv
        do iside=1,2*ldim
          if(cbc(iside,e,1).eq.'W  ')then
            i0=1
            j0=1
            k0=1
            i1=lx1
            j1=ly1
            k1=lz1
            if(iside.eq.1) then
              j0=2
              j1=2
            elseif(iside.eq.2) then
              i0=lx1-1
              i1=lx1-1
            elseif(iside.eq.3) then
              j0=ly1-1
              j1=ly1-1
            elseif(iside.eq.4) then
              i0=2
              i1=2
            elseif(iside.eq.5) then
              k0=2
              k1=2
            elseif(iside.eq.6) then
              k0=lz1-1
              k1=lz1-1
            endif
            do i=i0,i1
            do j=j0,j1
            do k=k0,k1
              iw=i
              jw=j
              kw=k
              if    (iside.eq.1) then
                jw=1
                norm(1)=unx(iw,kw,iside,e)
                norm(2)=uny(iw,kw,iside,e)
                norm(3)=unz(iw,kw,iside,e)
              elseif(iside.eq.2) then
                iw=lx1
                norm(1)=unx(jw,kw,iside,e)
                norm(2)=uny(jw,kw,iside,e)
                norm(3)=unz(jw,kw,iside,e)
              elseif(iside.eq.3) then
                jw=ly1
                norm(1)=unx(iw,kw,iside,e)
                norm(2)=uny(iw,kw,iside,e)
                norm(3)=unz(iw,kw,iside,e)
              elseif(iside.eq.4) then
                iw=1
                norm(1)=unx(jw,kw,iside,e)
                norm(2)=uny(jw,kw,iside,e)
                norm(3)=unz(jw,kw,iside,e)
              elseif(iside.eq.5) then
                kw=1
                norm(1)=unx(iw,jw,iside,e)
                norm(2)=uny(iw,jw,iside,e)
                norm(3)=unz(iw,jw,iside,e)
              else
                kw=lx1
                norm(1)=unx(iw,jw,iside,e)
                norm(2)=uny(iw,jw,iside,e)
                norm(3)=unz(iw,jw,iside,e)
              endif
              ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(e-1)*lxyz
              wpoint=iw+(jw-1)*lx1+(kw-1)*lx1*ly1+(e-1)*lxyz
              if(iflomach) then
                mu=visc(wpoint)
                rho=dens(wpoint)
              else
                mu=visc(1)
                rho=dens(1)
              endif

              do i2=1,ldim
              tau(i2)=0.0
                do j2=1,ldim
                  tau(i2)=tau(i2)+
     &             mu*(gradu(wpoint,i2,j2)+gradu(wpoint,j2,i2))*norm(j2)
                enddo
              enddo

              vsca=0.0
              do i2=1,ldim
                vsca=vsca+tau(i2)*norm(i2)
              enddo

              tauw=0.0
              do i2=1,ldim
                tauw=tauw+(tau(i2)-vsca*norm(i2))**2
              enddo
              tauw=sqrt(tauw)
              utau=sqrt(tauw/rho)
              yp=wd(ipoint)*utau*rho/mu
              ypmin=min(ypmin,yp)
              ypmax=max(ypmax,yp)
              ypave=ypave+yp
              nyp=nyp+1
            enddo
            enddo
            enddo
          endif
        enddo
      enddo

      ypmin=glmin(ypmin,1)
      ypmax=glmax(ypmax,1)
      ypave=glsum(ypave,1)
      nyp=iglsum(nyp,1)
      ypave=ypave/dble(nyp)

      return
      end
c-----------------------------------------------------------------------
