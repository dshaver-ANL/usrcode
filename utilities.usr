c-----------------------------------------------------------------------
      real function planar_ave_m1(phi,norm,pt,eps)
      implicit none
C
C     Compute area average of phi() on the
C     plane defined by normal 'norm' and point 'pt'
C
      include 'SIZE'
      include 'TOTAL'

      real phi(1),norm(3),pt(3),eps
      real aa,bb,cc,dd,w1,w2,x0,y0,z0,r0,rr,del,glsum

      integer i,j,k,n

      n=nx1*ny1*nz1*nelv

      aa=norm(1)
      bb=norm(2) 
      cc=0.0
      if(if3d) cc=norm(3)
      dd=-1.0*(aa*pt(1)+bb*pt(2)+cc*pt(3))
      w1=0.0
      w2=0.0
      do i=1,n
        x0=xm1(i,1,1,1)
        y0=ym1(i,1,1,1)
        z0=zm1(i,1,1,1)
        r0=(aa*x0+bb*y0+cc*z0+dd)/sqrt(aa**2+bb**2+cc**2)
        rr=min(2.0,abs(r0)*2.0/eps)
        if(rr.gt.1.0) then
          del = 1.0/8.0*(5.0-2.0*rr-sqrt(-7.0+12.0*rr-4.0*rr**2))
        else 
          del = 1.0/8.0*(3.0-2.0*rr+sqrt( 1.0+ 4.0*rr-4.0*rr**2))
        endif
        w1=w1+phi(i)*bm1(i,1,1,1)*del
        w2=w2+bm1(i,1,1,1)*del
      enddo
      planar_ave_m1 = glsum(w1,1)/max(glsum(w2,1),1.0e-8)

      return
      end
C-----------------------------------------------------------------------
      real function planar_ave_m2(phi,norm,pt,eps)
      implicit none
C
C     Compute area average of phi() on the
C     plane defined by normal 'norm' and point 'pt'
C
      include 'SIZE'
      include 'TOTAL'

      real phi(1),norm(3),pt(3),eps
      real aa,bb,cc,dd,w1,w2,x0,y0,z0,r0,rr,del,glsum

      integer i,j,k,n

      n=lx2*ly2*lz2*nelv

      aa=norm(1)
      bb=norm(2) 
      cc=0.0
      if(if3d) cc=norm(3)
      dd=-1.0*(aa*pt(1)+bb*pt(2)+cc*pt(3))
      w1=0.0
      w2=0.0
      do i=1,n
        x0=xm2(i,1,1,1)
        y0=ym2(i,1,1,1)
        z0=zm2(i,1,1,1)
        r0=(aa*x0+bb*y0+cc*z0+dd)/sqrt(aa**2+bb**2+cc**2)
        rr=min(2.0,abs(r0)*2.0/eps)
        if(rr.gt.1.0) then
          del = 1.0/8.0*(5.0-2.0*rr-sqrt(-7.0+12.0*rr-4.0*rr**2))
        else 
          del = 1.0/8.0*(3.0-2.0*rr+sqrt( 1.0+ 4.0*rr-4.0*rr**2))
        endif
        w1=w1+phi(i)*bm2(i,1,1,1)*del
        w2=w2+bm2(i,1,1,1)*del
      enddo
      planar_ave_m2 = glsum(w1,1)/max(glsum(w2,1),1.0e-8)

      return
      end
C-----------------------------------------------------------------------
      subroutine count_boundaries
      include 'SIZE'
      include 'TOTAL'

      integer lxyz,ielem,iside,n
      parameter(lxyz=lx1*ly1*lz1)
      character*3 uid(ldimt1)
      integer wcnt(ldimt1),symcnt(ldimt1),ocnt(ldimt1)
      integer tcnt(ldimt1),fcnt(ldimt1),axicnt(ldimt1)
      integer inscnt(ldimt1),pcnt(ldimt1),othcnt(ldimt1)
      integer vcnt(ldimt1),trcnt(ldimt1),ukncnt(ldimt1)
      integer mtrcnt(ldimt1),prcnt(ldimt1),intcnt(ldimt1)
      integer vreacnt(ldimt1),treacnt(ldimt1),convcnt(ldimt1)

      call izero(wcnt,ldimt1)
      call izero(trcnt,ldimt1)
      call izero(mtrcnt,ldimt1)
      call izero(vcnt,ldimt1)
      call izero(vreacnt,ldimt1)
      call izero(symcnt,ldimt1)
      call izero(ocnt,ldimt1)
      call izero(tcnt,ldimt1)
      call izero(treacnt,ldimt1)
      call izero(axicnt,ldimt1)
      call izero(inscnt,ldimt1)
      call izero(intcnt,ldimt1)
      call izero(fcnt,ldimt1)
      call izero(pcnt,ldimt1)
      call izero(prcnt,ldimt1)
      call izero(convcnt,ldimt1)
      call izero(othcnt,ldimt1)
      call izero(ukncnt,ldimt1)

      do ifld=1,nfield
        n=nelv
        if(iftmsh(ifld)) n=nelt
        do ielem=1,n
        do iside=1,2*ldim
          if(cbc(iside,ielem,ifld).eq.'W  ')then
            wcnt(ifld)=wcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'shl')then
            trcnt(ifld)=trcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'sml')then
            mtrcnt(ifld)=mtrcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'v  ')then
            vcnt(ifld)=vcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'V  ')then
            vreacnt(ifld)=vreacnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'t  ')then
            tcnt(ifld)=tcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'T  ')then
            treacnt(ifld)=treacnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'O  ')then
            ocnt(ifld)=ocnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'o  ')then
            prcnt(ifld)=prcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'P  ')then
            pcnt(ifld)=pcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'f  ')then 
            fcnt(ifld)=fcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'c  ')then 
            convcnt(ifld)=convcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'I  ')then
            inscnt(ifld)=inscnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'SYM')then
            symcnt(ifld)=symcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'A  ')then
            axicnt(ifld)=axicnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).eq.'int')then
            intcnt(ifld)=intcnt(ifld)+1
          elseif(cbc(iside,ielem,ifld).ne.'E  ')then
            if(ukncnt(ifld).eq.0) then  !handle one unknown BC
              uid(ifld)=cbc(iside,ielem,ifld)
              ukncnt(ifld)=1
            elseif(cbc(iside,ielem,ifld).eq.uid(ifld)) then
              ukncnt(ifld)=ukncnt(ifld)+1
            else
              othcnt(ifld)=othcnt(ifld)+1 !multiple unknown BCs 
            endif
          endif
        enddo
        enddo
        wcnt(ifld)=iglsum(wcnt(ifld),1)
        trcnt(ifld)=iglsum(trcnt(ifld),1)
        mtrcnt(ifld)=iglsum(mtrcnt(ifld),1)
        vcnt(ifld)=iglsum(vcnt(ifld),1)
        vreacnt(ifld)=iglsum(vreacnt(ifld),1)
        tcnt(ifld)=iglsum(tcnt(ifld),1)
        treacnt(ifld)=iglsum(treacnt(ifld),1)
        ocnt(ifld)=iglsum(ocnt(ifld),1)
        prcnt(ifld)=iglsum(prcnt(ifld),1)
        pcnt(ifld)=iglsum(pcnt(ifld),1)
        fcnt(ifld)=iglsum(fcnt(ifld),1)
        convcnt(ifld)=iglsum(convcnt(ifld),1)
        inscnt(ifld)=iglsum(inscnt(ifld),1)
        symcnt(ifld)=iglsum(symcnt(ifld),1)
        axicnt(ifld)=iglsum(axicnt(ifld),1)
        othcnt(ifld)=iglsum(othcnt(ifld),1)
        ukncnt(ifld)=iglsum(ukncnt(ifld),1)
      enddo

      if(nid.eq.0) then
        write(*,*)
        write(*,255) 'Found the following Boundary Conditions'
        write(*,*)
        do ifld=1,nfield
          write(*,254) 'for field',ifld,':'
          if(wcnt(ifld).gt.0)write(*,256)'Wall',wcnt(ifld)
          if(trcnt(ifld).gt.0)write(*,256)'Traction',trcnt(ifld)
          if(mtrcnt(ifld).gt.0)write(*,256)'Mixed Traction'
     &                                                   ,mtrcnt(ifld)
          if(vcnt(ifld).gt.0)write(*,256)'Velocity',vcnt(ifld)
          if(vreacnt(ifld).gt.0)write(*,256)'Velocity (REA)',
     &                                                   vreacnt(ifld)
          if(tcnt(ifld).gt.0)write(*,256)'Dirichlet',tcnt(ifld)
          if(treacnt(ifld).gt.0)write(*,256)'Dirichlet (REA)',
     &                                                   treacnt(ifld)
          if(pcnt(ifld).gt.0)write(*,256)'Periodic',pcnt(ifld)
          if(fcnt(ifld).gt.0)write(*,256)'Flux',fcnt(ifld)
          if(convcnt(ifld).gt.0)write(*,256)'Convection',convcnt(ifld)
          if(ocnt(ifld).gt.0)write(*,256)'Outlet',ocnt(ifld)
          if(prcnt(ifld).gt.0)write(*,256)'Pressure',prcnt(ifld)
          if(inscnt(ifld).gt.0)write(*,256)'Insulated',inscnt(ifld)
          if(intcnt(ifld).gt.0)write(*,256)'Interpolated',intcnt(ifld)
          if(symcnt(ifld).gt.0)write(*,256)'Symmetry',symcnt(ifld)
          if(axicnt(ifld).gt.0)write(*,256)
     &                                     'Axisymmetric',axicnt(ifld)
          if(ukncnt(ifld).gt.0)write(*,257)uid(ifld),ukncnt(ifld)
          if(othcnt(ifld).gt.0)write(*,256)'Other',othcnt(ifld)
          write(*,*)
        enddo
      endif

 254  format(5x,a,i2,a)
 255  format(2x,a)
 256  format(2x,a16,1x,i12)
 257  format(2x,'Unknown boundary of type: "',a,'" ',i9)

      return
      end
C-----------------------------------------------------------------------
      subroutine div_check(phi)

      real phi(1)

      if(phi(1).ne.phi(1)) call exitt
      return
      end
C-----------------------------------------------------------------------
      subroutine get_limits(phi,phimin,phimax,phiave,dphi,phip,rmsphi,n)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer i,n,ntot,iglsum,n1,n2,nt
      real phi(1),phip(1),phimin,phimax,phiave,dphi,rmsphi
      real glmin,glmax,glsc2,glsum
      logical ifm2

      n1=lx1*ly1*lz1*nelv
      n2=lx2*ly2*lz2*nelv

      ifm2=.false.
      ntot=lx1*ly1*lz1*nelgv
      if(n.ne.n1) then
        ifm2=.true.
        ntot=lx2*ly2*lz2*nelgv
      endif

      rmsphi=0.0
      dphi=0.0
      if(istep.ge.1) then
        do i=1,n
          dphi=max(dphi,abs(phip(i)-phi(i)))
          rmsphi=rmsphi+(phip(i)-phi(i))**2
        enddo
        rmsphi=glsum(rmsphi,1)
        rmsphi=sqrt(rmsphi/real(ntot))/dt
      endif
      dphi=glmax(dphi,1)
      dphi=dphi/dt

      phimin=glmin(phi,n)
      phimax=glmax(phi,n)

      if(ifm2) then
        phiave=glsc2(phi,bm2,n2)/volvm2
      else
        phiave=glsc2(phi,bm1,n1)/volvm1 
      endif

      return
      end
C-----------------------------------------------------------------------
      subroutine get_limits_nodt(phi,phimin,phimax,phiave,n)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer n
      real phi(1),phimin,phimax,phiave
      real glmin,glmax,glsc2

      phimin=glmin(phi,n)
      phimax=glmax(phi,n)
      phiave=glsc2(phi,bm1,n)/volvm1

      return
      end
c-----------------------------------------------------------------------
      real function get_nearest(loc,coord)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ipoint,ierr
      real loc,coord(1),ds(2),dsg(2)

      ds(1)=1.0d30
      do ipoint=1,lx1*ly1*lz1*nelv
        if(abs(coord(ipoint)-loc).lt.ds(1)) then
          ds(1)=abs(coord(ipoint)-loc)
          ds(2)=coord(ipoint)
        endif
      enddo
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      get_nearest=dsg(2)
      return
      end
c-----------------------------------------------------------------------
      subroutine get_point3d(loc1,loc2,loc3,ix,iy,iz,eg)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ipoint,ierr,dsi,ix,iy,iz,ie,eg,jx,jy,jz,je
      real loc1,loc2,loc3,ds(2),dsg(2),dist(2)

      dist(2)=1.0d30
      do je=1,nelv
      do jz=1,lz1
      do jy=1,ly1
      do jx=1,lx1
        dist(1)=sqrt((loc1-xm1(jx,jy,jz,je))**2
     &           +(loc2-ym1(jx,jy,jz,je))**2+(loc3-zm1(jx,jy,jz,je))**2)
        if(dist(1).lt.dist(2)) then
          dist(2)=dist(1)
          ix=jx
          iy=jy
          iz=jz
          ie=je
        endif
      enddo
      enddo
      enddo
      enddo

      eg=lglel(ie)

      ds(1)=dist(2)

      ds(2)=dble(ix)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      ix=int(dsg(2))

      ds(2)=dble(iy)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      iy=int(dsg(2))

      ds(2)=dble(iz)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      iz=int(dsg(2))

      ds(2)=dble(eg)
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      eg=int(dsg(2))

      return
      end
c-----------------------------------------------------------------------
      real function get_nearest_face(loc,coord,norm)
      include 'mpif.h'
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i0,i1,j0,j1,k0,k1,i,j,k,ierr
      real loc,coord(1),ds(2),dsg(2),norm(3),fnorm(3),dp

      ds(1)=1.0d30
      do ielem=1,nelv
        do iside=1,ldim*2
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
          i=(i0+i1)/2
          j=(j0+j1)/2
          k=(k0+k1)/2
          ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+lx1*ly1*lz1*(ielem-1)
          call getSnormal(fnorm,i,j,k,iside,ielem)
          dp=fnorm(1)*norm(1)+fnorm(2)*norm(2)
          if(if3d) dp=dp+fnorm(3)*norm(3)
          if((1.0d0-abs(dp)).lt.1.0d-8)then
            if(abs(coord(ipoint)-loc).lt.ds(1)) then
              ds(1)=abs(coord(ipoint)-loc)
              ds(2)=coord(ipoint)
            endif
          endif
        enddo
      enddo
      call MPI_ALLREDUCE(ds,dsg,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC
     &                                             ,MPI_COMM_WORLD,ierr)
      get_nearest_face=dsg(2)
      return
      end
C-----------------------------------------------------------------------
      subroutine max_y_p(wd)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real wd(nx1,ny1,nz1,nelv)
      integer e,isd,i,i0,i1,j,j0,j1,k,k0,k1
      integer n
      real msk(lx1,ly1,lz1,lelv)
      real dwmax,dwmin,glmin,glmax

      n=nx1*ny1*nz1*nelv

      dwmax=-1.0d30
      dwmin=1.0d30

      call rone(msk,nx1*ny1*nz1*nelv)
      do e=1,nelv
        do isd=1,2*ndim
          if(cbc(isd,e,1).eq.'W  ') then
            call backpts(i0,i1,j0,j1,k0,k1,isd)
            do k=k0,k1
            do j=j0,j1
            do i=i0,i1
              msk(i,j,k,e)=0.0
            enddo
            enddo
            enddo
          endif
        enddo
        do isd=1,2*ndim
          if(cbc(isd,e,1).eq.'W  ') then
            call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,isd)
            do k=k0,k1
            do j=j0,j1
            do i=i0,i1
              msk(i,j,k,e)=1.0
            enddo
            enddo
            enddo
          endif
        enddo
      enddo
      call dssum(msk,nx1,ny1,nz1) !for elements with edges but not faces along a wall

      do i=1,n
        if(msk(i,1,1,1).lt.0.5)then
          dwmax=max(dwmax,wd(i,1,1,1))
          dwmin=min(dwmin,wd(i,1,1,1))
        endif
      enddo

      dwmax=glmax(dwmax,1)
      dwmin=glmin(dwmin,1)
      if(nid.eq.0) then
        write(*,256) 'maximum y_p = ',dwmax
        write(*,256) 'minimum y_p = ',dwmin
        write(*,*)
      endif
 256  format(2x,a,es15.5)

      return
      end
C-----------------------------------------------------------------------
      subroutine weighted_average(phi,wrt,loc,coord,norm,phia)
C
C     Compute planar averages of phi() weighted by wrt() on the
C     plane normal to norm() with intercept coord = loc
C
      include 'SIZE'
      include 'TOTAL'

      integer ielem,iside,i,i0,i1,j,j0,j1,k,k0,k1
      real phi(1),wrt(1),loc,coord(1),norm(3),phia
      real fnorm(3),dp,a1,phia1

      loc=get_nearest_face(loc,coord,norm)

      phia=0.0
      phia1=0.0
      do ielem=1,nelv
        do iside=1,ndim*2
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,iside)
          i=(i0+i1)/2  !just use the point in the middle of the face
          j=(j0+j1)/2
          k=(k0+k1)/2
          ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
          if(abs(coord(ipoint)-loc).lt.1.0d-8)then 
            call getSnormal(fnorm,i,j,k,iside,ielem)
            dp=fnorm(1)*norm(1)+fnorm(2)*norm(2)
            if(if3d) dp=dp+fnorm(3)*norm(3)
            if(abs(1.0d0-dp).lt.1.0d-8) then
              do i=i0,i1
              do j=j0,j1
              do k=k0,k1
                ipoint=i+(j-1)*lx1+(k-1)*lx1*ly1+(ielem-1)*lx1*ly1*lz1
                if    ((iside.eq.1).or.(iside.eq.3)) then
                  a1=area(i,k,iside,ielem)
                elseif((iside.eq.2).or.(iside.eq.4)) then
                  a1=area(j,k,iside,ielem)
                else
                  a1=area(i,j,iside,ielem)
                endif
                phia=phia+phi(ipoint)*wrt(ipoint)*a1
                phia1=phia1+wrt(ipoint)*a1
              enddo
              enddo
              enddo
            endif
          endif
        enddo
      enddo

      phia=glsum(phia,1)
      phia1=glsum(phia1,1)
      phia=phia/phia1

      return
      end
C-----------------------------------------------------------------------
      subroutine planar_average_weighted(phia,phi,wrt,w1,w2)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'

      real phi(nx1*ny1,nz1,nelv),wrt(nx1*ny1,nz1,nelv),phia(nz1,nelz)
      real w1(nz1,nelz),w2(nz1,nelz) !work arrays

      integer e,eg,ez,melxy,nz,i,k
      real zz,aa

      melxy=nelx*nely !number of elements in the plane
      nz=nz1*nelz !number of z-slices

      if(melxy.lt.1)then
        if(nio.eq.0)write(*,256)'nelx*nely'
        return
      elseif(nelz.lt.1) then
        if(nio.eq.0)write(*,256)'nelz'
        return
      elseif(melxy.gt.lelx*lely) then
        if(nio.eq.0)write(*,257)'nelx*nely','lelx*lely'
        return
      elseif(nelz.gt.lelz) then
        if(nio.eq.0)write(*,257)'nelz','lelz'
        return
      endif

 256  format(5x,'ERROR: ',a,' must be at least 1!')
 257  format(5x,'ERROR: ',a,' must be less than ',a,'!')

      call rzero(phia,nz)
      call rzero(w1,nz)

      do e=1,nelt
        eg=lglel(e)
        ez=1+(eg-1)/melxy !z-slice id
        do k=1,nz1
          do i=1,nx1*ny1
            zz=(1.0-zgm1(k,3))/2.0
            aa=zz*area(i,1,5,e)+(1.0-zz)*area(i,1,6,e)
            w1(k,ez)=w1(k,ez)+aa*wrt(i,k,e)
            phia(k,ez)=phia(k,ez)+aa*wrt(i,k,e)*phi(i,k,e)
          enddo
          if(abs(w1(k,ez)).lt.1.0d-10) w1(k,ez)=1.0d-10
        enddo
      enddo

      call gop(phia,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
      call invcol2(phia,w1,nz)

      return
      end
C-----------------------------------------------------------------------
      subroutine x_planar_average(phia,phi,w1,w2)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'

      real phi(nx1,ny1,nz1,nelv),wrt(nx1,ny1,nz1,nelv),phia(nx1,nelx)
      real w1(nx1,nelx),w2(nx1,nelx) !work arrays

      integer e,eg,ex,nx,i,j,estride
      real xx,aa

      if(ldim.gt.2) then
        write(*,'(5x,a)')
     &            "x-average routine only written for 2D genbox meshes!"
        return
      endif

      nx=nx1*nelx !number of z-slices

      call rzero(phia,nx)
      call rzero(w1,nx)

      do e=1,nelt
        eg=lglel(e)
        ex=mod(eg,nelx) !x-slice id
        if(ex.eq.0)ex=nelx
        do i=1,nx1
          do j=1,ny1
            xx=(1.0-zgm1(i,1))/2.0
            aa=zz*area(j,1,4,e)+(1.0-zz)*area(j,1,2,e)
            w1(i,ex)=w1(i,ex)+aa
            phia(i,ex)=phia(i,ex)+aa*phi(i,j,1,e)
          enddo
        enddo
      enddo

      call gop(phia,w2,'+  ',nx)
      call gop(w1,w2,'+  ',nx)
      call invcol2(phia,w1,nx)

      return
      end
C-----------------------------------------------------------------------
      subroutine x_average_weighted(phia,phi,wrt,w1,w2)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'

      real phi(nx1,ny1,nz1,nelv),wrt(nx1,ny1,nz1,nelv),phia(nx1,nelx)
      real w1(nx1,nelx),w2(nx1,nelx) !work arrays

      integer e,eg,ex,nx,i,j,estride
      real xx,aa

      if(lz1.gt.1) then
        write(*,'(5x,a)')
     &                   "x-average routine only written for 2D meshes!"
        return
      endif

      nx=nx1*nelx !number of z-slices

      call rzero(phia,nx)
      call rzero(w1,nx)

      do e=1,nelt
        eg=lglel(e)
        ex=mod(eg,nelx) !x-slice id
        if(ex.eq.0)ex=nelx
        do i=1,nx1
          do j=1,ny1
            xx=(1.0-zgm1(i,1))/2.0
            aa=zz*area(j,1,4,e)+(1.0-zz)*area(j,1,2,e)
            w1(i,ex)=w1(i,ex)+aa*wrt(i,j,1,e)
            phia(i,ex)=phia(i,ex)+aa*wrt(i,j,1,e)*phi(i,j,1,e)
          enddo
          if(abs(w1(i,ex)).lt.1.0d-10) w1(i,ex)=1.0d-10
        enddo
      enddo

      call gop(phia,w2,'+  ',nx)
      call gop(w1,w2,'+  ',nx)
      call invcol2(phia,w1,nx)

      return
      end
C-----------------------------------------------------------------------
      subroutine y_p_limits(wd,ypmin,ypmax,ypave,utmin,utmax,utave)
      implicit none
      include 'SIZE'
      include 'TOTAL'
C
C     NOTE: min value should work if domain has internal corners
C

      integer e,i,i0,i1,j,j0,j1,k,k0,k1,iw,jw,kw,i2,j2
      integer ipt,wpt,estrd,isd,jsd
      real msk(lx1,ly1,lz1,lelv)
      real gradu(lx1*ly1*lz1,3,3),wd(1)
      real tau(3),norm(3),vsca,tauw,utau,rho,mu
      real ypmin,ypmax,yp,ypave,vol,utmin,utmax,utave
      real glmin,glmax,glsum
      logical ifgrad, ifdid

      data ifdid /.false./
      save ifdid, msk

      ypmin=1.0d30
      ypmax=-1.0d30
      ypave=0.0
      utmin=1.0d30
      utmax=-1.0d30
      utave=0.0
      vol=0.0

C     first build the mask  (this mask ignores some points which maybe important... 
      if(.not.ifdid)then    ! need to look at it more closely)
        ifdid=.true.
        call rone(msk,nx1*ny1*nz1*nelv)
        do e=1,nelv
          do isd=1,2*ndim
            if(cbc(isd,e,1).eq.'W  ') then
              call backpts(i0,i1,j0,j1,k0,k1,isd)
              do k=k0,k1
              do j=j0,j1
              do i=i0,i1
                msk(i,j,k,e)=0.0
              enddo
              enddo
              enddo
            endif
          enddo
          do isd=1,2*ndim
            if(cbc(isd,e,1).eq.'W  ') then
              call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,isd)
              do k=k0,k1
              do j=j0,j1
              do i=i0,i1
                msk(i,j,k,e)=1.0
              enddo
              enddo
              enddo
            endif
          enddo
        enddo
        call dssum(msk,nx1,ny1,nz1) !for elements with edges but not faces along a wall
      endif

      do e=1,nelv
        ifgrad=.true.
        do isd=1,2*ndim
          if(cbc(isd,e,1).eq.'W  ')then
            estrd=(e-1)*nx1*ny1*nz1
            if(ifgrad)then
              call gradm11(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),vx,e)
              call gradm11(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),vy,e)
              if(if3d)
     &         call gradm11(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),vz,e)
              ifgrad=.false.
            endif
            call backpts(i0,i1,j0,j1,k0,k1,isd)
            do k=k0,k1
            do j=j0,j1
            do i=i0,i1
              if(msk(i,j,k,e).lt.0.5) then
                iw=i
                jw=j
                kw=k
                if    (isd.eq.1) then
                  jw=1
                elseif(isd.eq.2) then
                  iw=nx1
                elseif(isd.eq.3) then
                  jw=ny1
                elseif(isd.eq.4) then
                  iw=1
                elseif(isd.eq.5) then
                  kw=1
                else
                  kw=nx1
                endif
                call getSnormal(norm,iw,jw,kw,isd,e)
                ipt=i +(j -1)*nx1+(k -1)*nx1*ny1
                wpt=iw+(jw-1)*nx1+(kw-1)*nx1*ny1

                mu=vdiff(iw,jw,kw,e,1)
                rho=vtrans(iw,jw,kw,e,1)

                do i2=1,ldim
                tau(i2)=0.0
                  do j2=1,ldim
                    tau(i2)=tau(i2)+
     &                   mu*(gradu(wpt,i2,j2)+gradu(wpt,j2,i2))*norm(j2)
                  enddo
                enddo

                vsca=0.0
                do i2=1,ldim
                  vsca=vsca+tau(i2)*norm(i2)
                enddo

                tauw=0.0
                do i2=1,ldim
                  tauw=tauw+(tau(i2)-vsca*norm(i2))**2
                enddo
                tauw=sqrt(tauw)
                utau=sqrt(tauw/rho)
                yp=wd(ipt+estrd)*utau*rho/mu
                ypmin=min(ypmin,yp)
                ypmax=max(ypmax,yp)
                ypave=ypave+yp*bm1(i,j,k,e)
                utmin=min(utau,utmin)
                utmax=max(utau,utmax)
                utave=utave+utau*bm1(i,j,k,e)
                vol=vol+bm1(i,j,k,e)
              endif
            enddo
            enddo
            enddo
          endif
        enddo
      enddo

      ypmin=glmin(ypmin,1)
      ypmax=glmax(ypmax,1)
      ypave=glsum(ypave,1)
      utmin=glmin(utmin,1)
      utmax=glmax(utmax,1)
      utave=glsum(utave,1)
      vol=glsum(vol,1)
      ypave=ypave/vol
      utave=utave/vol

      return
      end
c-----------------------------------------------------------------------
      subroutine backpts(i0,i1,j0,j1,k0,k1,isd)
      implicit none
      include 'SIZE'

      integer i0,i1,j0,j1,k0,k1,isd

      i0=1
      j0=1
      k0=1
      i1=nx1
      j1=ny1
      k1=nz1
      if(isd.eq.1) then
        j0=2
        j1=2
      elseif(isd.eq.2) then
        i0=nx1-1
        i1=nx1-1
      elseif(isd.eq.3) then
        j0=ny1-1
        j1=ny1-1
      elseif(isd.eq.4) then
        i0=2
        i1=2
      elseif(isd.eq.5) then
        k0=2
        k1=2
      elseif(isd.eq.6) then
        k0=nz1-1
        k1=nz1-1
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine print_limits
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real vol,glsum,glmin,glmax,glsc2
      real tmp(lx1*ly1*lz1*lelv)
      integer i,n1,n2,nt,nf

C     Primitive Variables
      real uxmin,uxmax,uxave,uymin,uymax,uyave,uzmin,uzmax,uzave
      real prmin,prmax,prave
      real thmin(ldimt),thmax(ldimt),thave(ldimt)
      real rmsux,rmsuy,rmsuz,rmspr,rmsth(ldimt),glrms
      real dux,duy,duz,dpr,dth(ldimt)
      character*15 tname

      n1=lx1*ly1*lz1*nelv
      n2=lx2*ly2*lz2*nelv
      nt=lx1*ly1*lz1*nelt

      if(ifflow) then
        call get_limits(vx,uxmin,uxmax,uxave,dux,vxlag,rmsux,n1)
        call get_limits(vy,uymin,uymax,uyave,duy,vylag,rmsuy,n1)
       if(if3d) call get_limits(vz,uzmin,uzmax,uzave,duz,vzlag,rmsuz,n1)
        call get_limits(pr,prmin,prmax,prave,dpr,prlag,rmspr,n2)
      endif
      if(ifheat) then
        do i=1,npscal+1
          nf=n1
          if(iftmsh(i+1))nf=nt
          if(idpss(i).eq.0) call get_limits(t(1,1,1,1,i),thmin(i) !Helmholtz solver
     &          ,thmax(i),thave(i),dth(i),tlag(1,1,1,1,1,i),rmsth(i),nf)
          if(idpss(i).eq.1) call get_limits_nodt(t(1,1,1,1,i) !CVODE solver
     &                                   ,thmin(i),thmax(i),thave(i),nf)
        enddo
      endif

      if(nio.eq.0) then
        write(*,*)
        write(*,254) 'limits','min','max','ave','max d/dt','rms d/dt'
        if(ifflow) then
          write(*,255) 'u velocity',uxmin,uxmax,uxave,dux,rmsux
          write(*,255) 'v velocity',uymin,uymax,uyave,duy,rmsuy
          if(if3d) write(*,255) 'w velocity',uzmin,uzmax,uzave,duz,rmsuz
          write(*,255) 'pressure',prmin,prmax,prave,dpr,rmspr
        endif
        if(ifheat) then
          do i=1,npscal+1
            if(i.eq.1) write(tname,'(a15)') "temperature"
            if(i.gt.1) write(tname,'(a14,i1)') "PS ",i-1
            if(idpss(i).eq.0)write(*,255)
     &               tname,thmin(i),thmax(i),thave(i),dth(i),rmsth(i)
            if(idpss(i).eq.1)write(*,256)
     &               tname,thmin(i),thmax(i),thave(i),'--','--'
          enddo
        endif
        write(*,*)
      endif

c     call copy(prlag,pr,n2)  no longer necessary as of commit 6616c87a0f9ecd946701dc7e43b997350a2a57b9

 254  format(a15,5a13)
 255  format(a15,5es13.4)
 256  format(a15,3es13.4,2a13)

      return
      end
c-----------------------------------------------------------------------
      real function q_vol_periodic(ix,iy,iz,ie)
      implicit none
      include 'SIZE'
      include 'TOTAL'
 
      integer ix,iy,iz,ie,n,e,f

      logical ifdid

      real dummy,sarea,tarea,time0,tcorr
      real f_gm,vel_avg,glsum,glsc2

      data ifdid /.false./
      data time0 /-1.0/

      save ifdid,time0,vel_avg,f_gm

      n=nx1*ny1*nz1*nelv

      if(.not.ifdid) then
        ifdid = .true.
        tarea = 0.0
        do e=1,nelv
          do f=1,2*ndim
            if(cbc(f,e,2).eq.'f  ') then
              call surface_int(dummy,sarea,xm1,e,f)
              tarea=tarea+sarea
            endif
          enddo
        enddo
        tarea=glsum(tarea,1)
        f_gm=abs(tarea/volvm1)
      endif

      if(time.ne.time0) then
        time0=time
        if(abs(param(54)).eq.1.0) vel_avg=glsc2(vx,bm1,n)/volvm1
        if(abs(param(54)).eq.2.0) vel_avg=glsc2(vy,bm1,n)/volvm1
        if(abs(param(54)).eq.3.0) vel_avg=glsc2(vz,bm1,n)/volvm1
        tcorr = -1.0*glsc2(t,bm1,n)/volvm1
        call cadd (t,tcorr,n)
      endif

      if(abs(param(54)).eq.1.0) 
     &                  q_vol_periodic=-1.0*f_gm*vx(ix,iy,iz,ie)/vel_avg
      if(abs(param(54)).eq.2.0)
     &                  q_vol_periodic=-1.0*f_gm*vy(ix,iy,iz,ie)/vel_avg
      if(abs(param(54)).eq.3.0)
     &                  q_vol_periodic=-1.0*f_gm*vz(ix,iy,iz,ie)/vel_avg

      return
      end
c-----------------------------------------------------------------------
       real function bc_average(phi,bca,ifld)
       implicit none
       include 'SIZE'
       include 'INPUT'

       character*3 bca
       integer ifld
       real phi(lx1*ly1*lz1*lelv)

       integer f,e
       real phibc,Abc,dphi,dA
       real glsum

       phibc=0.0
       Abc=0.0
 
       do e=1,nelt
         do f=1,ndim*2
           if(cbc(f,e,ifld).eq.bca) then
             call surface_int(dphi,dA,phi,e,f)
             phibc=phibc+dphi
             Abc=Abc+dA
           endif
         enddo
       enddo
       Abc=glsum(Abc,1)
       phibc=glsum(phibc,1)/Abc

       bc_average = phibc

       return
       end
c-----------------------------------------------------------------------
       real function bc_max(phi,bca,ifld)
       implicit none
       include 'SIZE'
       include 'INPUT'

       character*3 bca
       integer ifld
       real phi(lx1,ly1,lz1,1)

       real glmax

       integer f,e,i,i0,i1,j,j0,j1,k,k0,k1
       real bcmx

       do 10 e=1,nelt
       do 10 f=1,ndim*2
         if(cbc(f,e,ifld).eq.bca) then
           call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,f)
           do 20 k=k0,k1
           do 20 j=j0,j1
           do 20 i=i0,i1
             bcmx=max(bcmx,phi(i,j,k,e))
 20        continue
         endif
 10    continue

       bc_max = glmax(bcmx,1)

       return
       end
c-----------------------------------------------------------------------
       subroutine average_files(inbase,lbase,navg)
       implicit none
       include 'SIZE'
       include 'TOTAL'
       include 'AVG'
 
       character     inbase(1),fbas1(124)
       character*124 fbase
       character*8   ftail
       integer lbase,navg,n,n2,i,j

       equivalence (fbas1,fbase)
 
       n=nx1*ny1*nz1*nelv
       n2=nx2*ny2*nz2*nelv

       call blank(fbase,124)
       do i=1,lbase
         fbas1(i)=inbase(i)
       enddo
 
       if(navg.gt.0.and.nsteps.eq.0) then
         atime=0.0
         call rzero(uavg,n)
         call rzero(vavg,n)
         call rzero(wavg,n)
         call rzero(pavg,n2)
         do j=1,ldimt
           call rzero(tavg(1,1,1,1,j),n)
         enddo
         do i=1,navg
           if(i.lt.10) then
             write(ftail,'(a7,i1)')'0.f0000',i
           elseif(i.lt.100) then
             write(ftail,'(a6,i2)')'0.f000',i
           elseif(i.lt.1000) then
             write(ftail,'(a5,i3)')'0.f00',i
           endif
           call blank(initc(1),132)
           initc(1)=trim(fbase)//ftail
 
           call restart(1)
 
           atime=atime+time
           call add2s2(uavg,vx,time,n)
           call add2s2(vavg,vy,time,n)
           call add2s2(wavg,vz,time,n)
           call add2s2(pavg,pr,time,n2)
           do j=1,ldimt
             call add2s2(tavg(1,1,1,1,j),t(1,1,1,1,j),time,n)
           enddo
         enddo
         time=atime
         call cmult(uavg,1.0/atime,n)
         call cmult(vavg,1.0/atime,n)
         call cmult(wavg,1.0/atime,n)
         call cmult(pavg,1.0/atime,n2)
         do j=1,ldimt
           call cmult(tavg(1,1,1,1,j),1.0/atime,n)
         enddo
 
         call copy (vx,uavg,n)
         call copy (vy,vavg,n)
         call copy (vz,wavg,n)
         call copy (pr,pavg,n2)
         do j=1,ldimt
           call copy(t(1,1,1,1,j),tavg(1,1,1,1,j),n)
         enddo
       endif
 
       return
       end
c-----------------------------------------------------------------------
       subroutine print_Nusselt
       include 'SIZE'
       include 'TOTAL'

       logical ifdo
       save ifdo
       data ifdo /.true./

       if(.not.ifdo) return

       if(abs(param(54)).lt.0.1) then
         ifdo=.false.
         if(nio.eq.0) then
           write(*,'(a)') "******************************"
           write(*,'(a)')
     &       "print_Nusselt routine only compatible with forced flow"
           write(*,'(a)') "******************************"
         endif
         return
       endif

       n=nx1*ny1*nz1*nelv

       tarea=0.0
       twall=0.0
       do ie=1,nelt
         do ifa=1,2*ndim
           if(cbc(ifa,ie,2).eq.'f  ') then
             call surface_int(swall,sarea,t,ie,ifa)
             twall=twall+swall
             tarea=tarea+sarea
           endif
         enddo
       enddo
       tarea=glsum(tarea,1)
       twall=glsum(twall,1)/tarea

      if(abs(param(54)).eq.1.0) tbulk=glsc3(t,vx,bm1,n)/glsc2(vx,bm1,n)
      if(abs(param(54)).eq.2.0) tbulk=glsc3(t,vy,bm1,n)/glsc2(vy,bm1,n)
      if(abs(param(54)).eq.3.0) tbulk=glsc3(t,vz,bm1,n)/glsc2(vz,bm1,n)

      rNus=1.0/((twall-tbulk)*cpfld(2,1))
      if(nio.eq.0) then
        write(*,'(a16,2es15.7)') "time, Nusselt",time,rNus
        write(*,*)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine get_face_m1centroid(xx,yy,zz,ie,iface)
      implicit none
      include 'SIZE'
      include 'GEOM'
      include 'MASS'

      integer ie,iface
      real xx,yy,zz

      integer i,i0,i1,j,j0,j1,k,k0,k1
      real bm0

      bm0=0.0
      call facind(i0,i1,k0,k1,j0,j1,nx1,ny1,nz1,iface)
      do 10 k=k0,k1
      do 10 j=j0,j1
      do 10 i=i0,i1
        bm0=bm0+bm1(i,j,k,ie)
        xx=xx+xm1(i,j,k,ie)*bm1(i,j,k,ie)
        yy=yy+ym1(i,j,k,ie)*bm1(i,j,k,ie)
        zz=zz+zm1(i,j,k,ie)*bm1(i,j,k,ie)
 10   continue

      xx=xx/bm0
      yy=yy/bm0
      zz=zz/bm0

      return
      end
c-----------------------------------------------------------------------
      subroutine get_elem_m1centroid(xx,yy,zz,ie)
      implicit none
      include 'SIZE'
      include 'GEOM'
      include 'MASS'

      integer ie
      real xx,yy,zz

      integer ipt
      real bb

      xx=0.0
      yy=0.0
      zz=0.0
      bb=0.0
      do ipt = 1,lx1*ly1*lz1
        xx=xx+xm1(ipt,1,1,ie)*bm1(ipt,1,1,ie)
        yy=yy+ym1(ipt,1,1,ie)*bm1(ipt,1,1,ie)
        zz=zz+zm1(ipt,1,1,ie)*bm1(ipt,1,1,ie)
        bb=bb+bm1(ipt,1,1,ie)
      enddo
      xx=xx/bb
      yy=yy/bb
      zz=zz/bb

      return
      end
c-----------------------------------------------------------------------
      subroutine rotate_point_2d(x1,y1,x0,y0,theta,xo,yo)
      implicit none

      real x1,y1,x0,y0,theta,xo,yo

      xo=(x1-x0)*cos(theta)-(y1-y0)*sin(theta)+x0
      yo=(x1-x0)*sin(theta)+(y1-y0)*cos(theta)+y0

      return
      end
c-----------------------------------------------------------------------
      subroutine flag_bndry(bcc,ifld,phi)
      implicit none
      include 'SIZE'
      include 'INPUT'

      character*3 bcc 
      integer ifld
      real phi(lx1,ly1,lz1,1)

      integer ie,ifc,i,i0,i1,j,j0,j1,k,k0,k1,n
 
      n=lx1*ly1*lz1*nelv
      call rzero(phi,n)

      do 10 ie=1,nelt
      do 10 ifc=1,ndim*2
        if(cbc(ifc,ie,ifld).eq.bcc) then
          call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,ifc)
          do 20 k=k0,k1
          do 20 j=j0,j1
          do 20 i=i0,i1
            phi(i,j,k,ie)=1.0
 20       continue
        endif
 10   continue
 
      return
      end
