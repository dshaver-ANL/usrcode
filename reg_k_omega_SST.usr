C-----------------------------------------------------------------------
C  USER SPECIFIED ROUTINE: reg_k_omega_SST
C
C	include this in the .usr file to add the k-omega model
C	Note: this will probably have to be adjusted to account for 
C		the two-fluid model
C       provides:
C		reg_k_omega_SST
C			subroutine for computing the source terms
C			for the k-omega model and the eddy viscosity
C			call this in usrchk
C		omega_base
C			subroutine for computing the omega base terms,
C			omega_w,gradow,lapow.  For constant properties
C			and a non-deforming mesh, this only needs to be
C 			called once.
C	requires:
C		wd(lx1,ly1,lz1,lelv) array specifying the distance to 
C			the nearest wall (passed to omega_base)
C               dens(lx1,ly1,lz1,lelv) array specifying fluid density
C               visc(lx1,ly1,lz1,lelv) the same for viscosity (mu)
C		omega_in - value of omega on the inlet boundary
C		nu_in - constant reference kinematic viscosity (used to
C			evaluate omega_w since omega_w is assumed not to
C			vary with time)
C-----------------------------------------------------------------------
      subroutine reg_k_omega_SST(velu,velv,velw,wd,dens,visc,tke,omega
     &                   ,omega_in,nu_in,src_k,src_o,src_t,mu_t,ski,soi)
      implicit none
      include 'SIZE'
      include 'INPUT'
      include 'TSTEP'
      include 'MASS'

      integer iglsum
      integer lxyze
      parameter (lxyze=lx1*ly1*lz1*lelv)
      integer i,j,ipt,iclip_k,ilim_k,iclip_o,ilim_o,n
      real velu(1),velv(1),velw(1),wd(1),tke(1),omega(1),dens(1),visc(1)
      real src_k(1),src_o(1),src_t(1),mu_t(1),soi(1),ski(1)
      real omega_in,nu_in
      real tke0,omega0,rho,mu,vist,omega_hat,vistmax,ywm1,ywm2,divu
      real omega_w(lxyze),gradow(lxyze,3),lapow(lxyze)
      real gradu(lxyze,3,3),gradk(lxyze,3),grado(lxyze,3)
      real dif_o(lxyze),graddo(lxyze,3)
      real prod_ratio,Gk,Yk,Go,Yo,tau_ij,O_ij,O_mag,two3rds
      real F1,F2,psi1,psi11,psi12,psi2,psi21,psi22,CDko,Xk
      real beta_st,alpha,beta,gamm,sigk,sigo
      real beta1,beta2,gamm1,gamm2,sigk1,sigk2,sigo1,sigo2
      parameter (beta_st=9.0d-2,    alpha=3.1d-1)
      parameter (beta1=7.5d-2,      beta2=8.28d-2)
      parameter (gamm1=5.0d0/9.0d0, gamm2=4.4d-1)
      parameter (sigk1=8.5d-1,      sigk2=1.0)
      parameter (sigo1=5.0d-1,      sigo2=8.56d-1)
      parameter (prod_ratio=5.0d1,two3rds=2.0d0/3.0d0)

      save omega_w,gradow,lapow

      n=nx1*ny1*nz1*nelv

      iclip_k=0
      ilim_k=0
      iclip_o=0
      ilim_o=0

      if(istep.lt.1)
     &           call omega_base(wd,nu_in,omega_in,omega_w,gradow,lapow)

c     find gradients of the necessary primitive variables
      call gradm1(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),velu) !grad u
      call gradm1(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),velv) !grad v
      call gradm1(gradk(1,1),gradk(1,2),gradk(1,3),tke)        !grad tke
      call gradm1(grado(1,1),grado(1,2),grado(1,3),omega)      !grad omega'

c     multiply gradients by the mass matrix
      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),bm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),bm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),bm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),bm1)

c     reconcile gradients at element boundaries
      call opdssum(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3))
      call opdssum(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3))
      call opdssum(gradk(1,1),gradk(1,2),gradk(1,3))
      call opdssum(grado(1,1),grado(1,2),grado(1,3))

c     multiply gradients by the inverse mass matrix
      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),binvm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),binvm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),binvm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),binvm1)

c     total gradient of omega is the sum of the two components
      call add2(grado(1,1),gradow(1,1),n)
      call add2(grado(1,2),gradow(1,2),n)
      call add2(grado(1,3),gradow(1,3),n)
      
c     do the above for w-velocity
      if(if3d) then
        call gradm1(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),velw)
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),bm1)
        call opdssum(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3))
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),binvm1)
      endif

      do ipt=1,n !for every point in the velocity mesh

        if(tke(ipt).lt.0.0) then !limit on tke to keep it positive
          tke0=1.0d-2*abs(tke(ipt))
          tke(ipt)=tke0
          ilim_k=ilim_k+1
        else
          tke0=tke(ipt)
        endif

        if(omega(ipt).lt.0.0) then !limit on omega to keep it positive
          omega0=1.0d-2*abs(omega(ipt))
          omega(ipt)=omega0
          ilim_o=ilim_o+1
        endif
        omega0=omega(ipt)+omega_w(ipt)

c       if(iflomach)then  !still needs to be tested
c         divu=gradu(ipt,1,1)+gradu(ipt,2,2)
c         if(if3d) divu=divu+gradu(ipt,3,3)
c       else
          divu=0.0
c       endif

        ywm1=0.0
        ywm2=0.0
        if(wd(ipt).gt.0.0) then
          ywm1=1.0/wd(ipt)
          ywm2=ywm1*ywm1
        endif

        if(iflomach) then
          rho=dens(ipt)
          mu=visc(ipt)
        else
          rho=dens(1)
          mu=visc(1)
        endif
        vistmax=5.0d3*mu

        O_mag=0.0
        Xk=0.0
        do i=1,ndim
          Xk=Xk+gradk(ipt,i)*grado(ipt,i)
          do j=1,ndim
            O_ij=5.0d-1*(gradu(ipt,i,j)-gradu(ipt,j,i))
            O_mag=O_mag+O_ij*O_ij
          enddo
        enddo
        O_mag=sqrt(2.0d0*O_mag)
        Xk=2.0d0*(rho*sigo2/omega0)*Xk

        CDko=max(Xk,1.0d-20)
        psi22=5.0d2*mu*ywm2/(rho*omega0)
        psi21=sqrt(tke0)*ywm1/(beta_st*omega0)
        psi12=4.0d0*rho*sigo2*tke0*ywm2/CDko
        psi11=max(psi21,psi22)
        psi2=max(2.0d0*psi21,psi22)
        psi1=min(psi11,psi12)
        F2=tanh(psi2*psi2)
        F1=tanh(psi1*psi1*psi1*psi1)

        sigk=F1*sigk1+(1.0d0-F1)*sigk2
        sigo=F1*sigo1+(1.0d0-F1)*sigo2
        beta=F1*beta1+(1.0d0-F1)*beta2
        gamm=F1*gamm1+(1.0d0-F1)*gamm2

        vist=alpha*rho*tke0/max(alpha*omega0,O_mag*F2)
        vist=min(vist,vistmax)
        mu_t(ipt)=vist !update eddy viscosity
        ski(ipt)=1.0d0/sigk
        soi(ipt)=1.0d0/sigo

        Gk=0.0 !k production
        do i=1,ndim
          do j=1,ndim
            tau_ij=vist*(gradu(ipt,i,j)+gradu(ipt,j,i))
            if(i.eq.j) tau_ij=tau_ij-two3rds*(vist*divu+rho*tke0)
            Gk=Gk+gradu(ipt,i,j)*tau_ij
          enddo
        enddo

        Yk=rho*beta_st*tke0*omega0 !k destruction

        src_t(ipt)=Yk !viscous dissipation term (turns tke into heat)

        if(Gk.gt.prod_ratio*Yk) then !turbulence production clip
          iclip_k=iclip_k+1
          Gk=prod_ratio*Yk
        endif

        src_k(ipt)=Gk-Yk

c       omega source production
        Go=(gamm*max(alpha*omega0,O_mag*F2)/(alpha*tke0))*Gk
        Go=Go+(1.0d0-F1)*Xk

        Yo=rho*beta*omega0**2 !omega destruction

        if(Go.gt.prod_ratio*Yo) then !omega production clip
          iclip_o=iclip_o+1
          Go=prod_ratio*Yo
        endif

        src_o(ipt)=Go-Yo

        dif_o(ipt)=mu+vist/sigo
      enddo !1..ipt..n

c     add dif_o times laplace omega_w to source term
      call addcol3(src_o,dif_o,lapow,n)

c     build grad dif_o
      call gradm1(graddo(1,1),graddo(1,2),graddo(1,3),dif_o)
      call opcolv(graddo(1,1),graddo(1,2),graddo(1,3),bm1)
      call opdssum(graddo(1,1),graddo(1,2),graddo(1,3))
      call opcolv(graddo(1,1),graddo(1,2),graddo(1,3),binvm1)

c     subtract rho u from grad dif_o
      if(iflomach) then
        call subcol3(graddo(1,1),dens,velu,n)
        call subcol3(graddo(1,2),dens,velv,n)
        if(if3d) call subcol3(graddo(1,3),dens,velw,n)
      else
        do ipt=1,n
          graddo(ipt,1)=graddo(ipt,1)-velu(ipt)*dens(1)
          graddo(ipt,2)=graddo(ipt,2)-velv(ipt)*dens(1)
          if(if3d)graddo(ipt,3)=graddo(ipt,3)-velw(ipt)*dens(1)
        enddo
      endif

c     add (grad dif_o - rho u) dot grad omega_w to source term
      call addcol3(src_o,graddo(1,1),gradow(1,1),n)
      call addcol3(src_o,graddo(1,2),gradow(1,2),n)
      if(if3d) call addcol3(src_o,graddo(1,3),gradow(1,3),n)

      iclip_k=iglsum(iclip_k,1)
      ilim_k=iglsum(ilim_k,1)
      iclip_o=iglsum(iclip_o,1)
      ilim_o=iglsum(ilim_o,1)

      if(nid.eq.0.and.(iclip_k+ilim_k+iclip_o+ilim_o).gt.0) then
        if(iclip_k.gt.0)
     &    write(*,101) '  TKE production clipped on ',iclip_k,' points'
        if(ilim_k.gt.0)
     &    write(*,101) '  TKE limited on ',ilim_k,' points'
        if(iclip_o.gt.0)
     &    write(*,101) 'Omega production clipped on ',iclip_o,' points'
        if(ilim_o.gt.0)
     &    write(*,101) 'Omega limited on ',ilim_o,' points'
        write(*,*)
      endif

101    format(a32,i9,a)

      end
c-----------------------------------------------------------------------
      subroutine omega_base(wd,nu_in,omega_in,omega_w,gradow,lapow)
      implicit none
      include 'SIZE'
      include 'INPUT'
      include 'MASS'

      integer lxyz,lxyze
      parameter (lxyz=lx1*ly1*lz1,lxyze=lxyz*lelv)
      integer i,j,ntot
      real omega_in,nu_in,wd(1),omega_w(1),gradow(lxyze,3),lapow(1)
      real gradphi(lxyze,3),gradowsq(lxyze)
      real Cfcon,expn,beta0,nu,delfp,delsfp,omega_max
      real yw,ymin,ywm2,ywm3,ywm4

      ntot=lxyz*nelv

      beta0=9.0d-2
      expn=-2.0d0
      omega_max=1.0d3*omega_in
      Cfcon=6.0d0*nu_in/beta0

      call gradm1(gradow(1,1),gradow(1,2),gradow(1,3),wd)
      call opcolv(gradow(1,1),gradow(1,2),gradow(1,3),bm1)
      call opdssum(gradow(1,1),gradow(1,2),gradow(1,3))
      call opcolv(gradow(1,1),gradow(1,2),gradow(1,3),binvm1)

      call gradm1(gradphi(1,1),gradphi(1,2),gradphi(1,3),gradow(1,1))
      call copy(lapow,gradphi(1,1),ntot)
      call gradm1(gradphi(1,1),gradphi(1,2),gradphi(1,3),gradow(1,2))
      call add2(lapow,gradphi(1,2),ntot)
      call gradm1(gradphi(1,1),gradphi(1,2),gradphi(1,3),gradow(1,3))
      call add2(lapow,gradphi(1,3),ntot)
      
      call vdot3(gradowsq,gradow(1,1),gradow(1,2),gradow(1,3)
     &                   ,gradow(1,1),gradow(1,2),gradow(1,3),ntot)

      do i=1,ntot
        yw=wd(i)
        ymin=sqrt(Cfcon/omega_max)
        if(yw.gt.ymin) then
          ywm2=1.0d0/(yw*yw)
          ywm3=ywm2/yw
          ywm4=ywm2*ywm2
        else !don't let the source terms go to zero
          ywm2=omega_max/Cfcon
          ywm3=ywm2/ymin
          ywm4=ywm2*ywm2
        endif

        omega_w(i)=Cfcon*ywm2
        delfp=expn*Cfcon*ywm3
        gradow(i,1)=delfp*gradow(i,1)
        gradow(i,2)=delfp*gradow(i,2)
        if(if3d)gradow(i,3)=delfp*gradow(i,3)
        delsfp=expn*(expn-1.0)*Cfcon*ywm4
        lapow(i)=delsfp*gradowsq(i)+delfp*lapow(i)
      enddo

      return
      end
c-----------------------------------------------------------------------
