C-----------------------------------------------------------------------
C  USER SPECIFIED ROUTINE: compute_rans
C       SMA - original code
C	DRS - 10/02/2015 - separated from temperature terms, reorganized
C                          and made modular
C	DRS - 02/04/2016 - played around with the limits, works for Pn-Pn
C			   formulation, but not with IFSTRS=T
C			   init_ko_ifld and update_vis_turb have been 
C			   deprecated
C	DRS - 03/15/2016 - all gradient variables have been reconciled  
C			   on the element faces by calling opdssum
C
C	include this in the .usr file to add the k-omega turbulence model
C	Note: this will probably have to be adjusted to account for 
C		the two-fluid model
C       provides:
C		standard_k_omega
C			subroutine for computing the source terms
C			for the k-omega model and the eddy viscosity
C			call this in usrchk
C-----------------------------------------------------------------------
      subroutine standard_k_omega(velu,velv,velw,tke,omega,dens,visc
     &                                          ,src_k,src_o,src_t,mu_t)
      include 'SIZE'
      include 'TOTAL'

      integer lxyz,lxyze
      parameter (lxyz=lx1*ly1*lz1,lxyze=lxyz*lelv)
      integer ielem,i,j,k,ipoint,iclip_k,ilim_k,iclip_o,ilim_o
      logical ifprint
      real velu(1),velv(1),velw(1),tke(1),omega(1),dens(1),visc(1)
      real src_k(1),src_o(1),src_t(1),mu_t(1)
      real tke0,omega0,rho,mu,vist
      real gradu(lxyze,3,3),gradk(lxyze,3),grado(lxyze,3)
      real G_phi,Y_phi !source and sink terms for k & omega
      real S_ij,S_jk,S_ki !strain and vorticity tensors
      real :: four15ths=4.0d0/1.5d1
      real :: tiny=1.0d-20 !very small number, in case divide by zero
      real :: R_Bi=1.25d-1 !1/R_beta
      real :: R_ki=1.0d0/6.0d0 !1/R_k
      real :: R_oi=2.0d1/5.9d1 !1/R_omega
      real :: beta_st_inf=9.0d-2 !C_mu??
      real :: beta_i=7.2d-2 !other constants
      real :: alph_inf=5.2d-1
      real :: alph_0=1.0d0/9.0d0
      real :: alph_st_inf=1.0d0
      real f_beta,chi,Re_t,beta_st,alph,alph_st,alph_st_0

      alph_st_0=beta_i/3.0d0

      iclip_k=0
      ilim_k=0
      iclip_o=0
      ilim_o=0

      call gradm1(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),velu)
      call gradm1(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),velv)
      call gradm1(gradk(1,1),gradk(1,2),gradk(1,3),tke)
      call gradm1(grado(1,1),grado(1,2),grado(1,3),omega)

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),bm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),bm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),bm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),bm1)

      call opdssum(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3))
      call opdssum(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3))
      call opdssum(gradk(1,1),gradk(1,2),gradk(1,3))
      call opdssum(grado(1,1),grado(1,2),grado(1,3))

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),binvm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),binvm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),binvm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),binvm1)

      if(if3d) then
        call gradm1(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),velw)
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),bm1)
        call opdssum(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3))
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),binvm1)
      endif

      do ipoint=1,lxyz*nelv !for every point in the element

        if(tke(ipoint).lt.0.0) then !limit on tke to keep it positive
          tke0=1.0d-2*dabs(tke(ipoint)) !don't actually change the variables in memory
          ilim_k=ilim_k+1
        else
          tke0=tke(ipoint)
        endif

        if(omega(ipoint).lt.0.0) then !limit on omega to keep it positive
          omega0=1.0d-2*dabs(omega(ipoint))
          ilim_o=ilim_o+1
        else
          omega0=omega(ipoint)
        endif

        rho=dens(ipoint)
        mu=visc(ipoint)

        Re_t=rho*tke0/dmax1(mu*omega0,tiny)
        alph_st=alph_st_inf*(alph_st_0+Re_t*R_ki)/(1.0d0+Re_t*R_ki)
        vist=rho*alph_st*tke0/dmax1(omega0,tiny)
        vist=min(vist,5.0d3*mu)
        mu_t(ipoint)=vist !update eddy viscosity

cccccccccccccccccccccccccccccccccccccccccccccccccc
c   k source and sink terms (phi=k)
cccccccccccccccccccccccccccccccccccccccccccccccccc
        G_phi=0.0 !build the k source term
        do i=1,ldim !ignore terms in dimensions that don't exist
          do j=1,ldim
            S_ij=5.0d-1*(gradu(ipoint,i,j)+gradu(ipoint,j,i))
            G_phi=G_phi+S_ij*S_ij !don't bother with the squaring of the sqrt
          enddo
        enddo
        G_phi=G_phi*vist*2.0d0

        chi=0.0 !build the chi_k term
        do i=1,ldim
          chi=chi+gradk(ipoint,i)*grado(ipoint,i)
        enddo
        chi=chi/dmax1(omega0**3,tiny)

        if(chi.le.0) then !f_beta_star
          f_beta=1.0d0
        else
          f_beta=(1+6.80d2*chi**2)/(1+4.0d2*chi**2)
        endif

        beta_st=beta_st_inf*f_beta*((four15ths+(R_Bi*Re_t)**4)/
     &    (1.0d0+(R_Bi*Re_t)**4))

        Y_phi=dabs(rho*beta_st*tke0*omega0) !k sink term (dissipation of tke)

        src_t(ipoint)=Y_phi !viscous dissipation term (turns tke into heat)

        if(G_phi.gt.5.0d1*Y_phi) then !turbulence production clip
          iclip_k=iclip_k+1
          G_phi=5.0d1*Y_phi
        endif

c       G_k(ipoint,1,1,ielem)=G_phi !debug arrays
c       Y_k(ipoint,1,1,ielem)=Y_phi

        src_k(ipoint)=G_phi-Y_phi

cccccccccccccccccccccccccccccccccccccccccccccccccc
c   omega source and sink terms (phi=o)
cccccccccccccccccccccccccccccccccccccccccccccccccc
        alph=(alph_inf*(alph_0+Re_t*R_oi))/(alph_st*(1.0d0+Re_t*R_oi))

        G_phi=G_phi*omega0/dmax1(tke0,tiny)*alph !G_phi is already G_k from above

        chi=0.0 !build the chi_omega term
        if(if3d) then !Pope Correction for 2D flows
          do i=1,ldim
            do j=1,ldim
              S_ij=5.0d-1*(gradu(ipoint,i,j)-gradu(ipoint,j,i)) !actually OMEGA
              do k=1,ldim
                S_jk=5.0d-1*(gradu(ipoint,j,k)-gradu(ipoint,k,j)) !also OMEGA
                S_ki=5.0d-1*(gradu(ipoint,k,i)+gradu(ipoint,i,k)) !really S this time
                chi=chi+S_ij*S_jk*S_ki
              enddo
            enddo
          enddo
          chi=dabs(chi/dmax1((beta_st_inf*omega0)**3,tiny))
        endif

        f_beta=(1.0d0+7.0d1*chi)/(1.0d0+8.0d1*chi)

        Y_phi=rho*beta_i*f_beta*omega0**2

        if(G_phi.gt.5.0d1*Y_phi) then !omega production clip
          iclip_o=iclip_o+1
          G_phi=5.0d1*Y_phi
        endif

c       G_o(ipoint,1,1,ielem)=G_phi !debug arrays
c       Y_o(ipoint,1,1,ielem)=Y_phi

        src_o(ipoint)=G_phi-Y_phi

      enddo !1..ipoint..lxyz

      iclip_k=iglsum(iclip_k,1)
      ilim_k=iglsum(ilim_k,1)
      iclip_o=iglsum(iclip_o,1)
      ilim_o=iglsum(ilim_o,1)

      if((iclip_k+ilim_k+clip_o+ilim_o).gt.0) then
        ifprint=.true.
      else
        ifprint=.false.
      endif

      if(nid.eq.0.and.ifprint) then
        if(iclip_k.gt.0)
     &    write(*,101) '  TKE production clipped on ',iclip_k,' points'
        if(ilim_k.gt.0)
     &    write(*,101) '  TKE limited on ',ilim_k,' points'
        if(iclip_o.gt.0)
     &    write(*,101) 'Omega production clipped on ',iclip_o,' points'
        if(ilim_o.gt.0)
     &    write(*,101) 'Omega limited on ',ilim_o,' points'
        write(*,*)
      endif

101    format(4x,a,i7,a)

      end
c-----------------------------------------------------------------------
