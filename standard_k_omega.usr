C-----------------------------------------------------------------------
C  USER SPECIFIED ROUTINE: compute_rans
C       SMA - original code
C	DRS - 10/02/2015 - separated from temperature terms, reorganized
C                          and made modular
C	DRS - 02/04/2016 - played around with the limits, works for Pn-Pn
C			   formulation, but not with IFSTRS=T
C			   init_ko_ifld and update_vis_turb have been 
C			   deprecated
C	DRS - 03/15/2016 - all gradient variables have been reconciled  
C			   on the element faces by calling opdssum
C
C	include this in the .usr file to add the k-omega turbulence model
C	Note: this will probably have to be adjusted to account for 
C		the two-fluid model
C       provides:
C		standard_k_omega
C			subroutine for computing the source terms
C			for the k-omega model and the eddy viscosity
C			call this in usrchk
C-----------------------------------------------------------------------
      subroutine standard_k_omega(velu,velv,velw,dens,visc,tke,omega
     &                                          ,src_k,src_o,src_t,mu_t)
      implicit none
      include 'SIZE'
      include 'INPUT'
      include 'MASS'

      integer iglsum
      integer lxyz,lxyze
      parameter (lxyz=lx1*ly1*lz1,lxyze=lxyz*lelv)
      integer ielem,i,j,k,ipt,iclip_k,ilim_k,iclip_o,ilim_o,n
      logical ifprint
      real velu(1),velv(1),velw(1),tke(1),omega(1),dens(1),visc(1)
      real src_k(1),src_o(1),src_t(1),mu_t(1)
      real tke0,omega0,rho,mu,vist,vistmax
      real gradu(lxyze,3,3),gradk(lxyze,3),grado(lxyze,3)
      real prod_ratio,G_phi,Y_phi !source and sink terms for k & omega
      real tau_ij,S_ki,O_ij,O_jk !stress, strain, and vorticity components
      real :: twothirds=2.0d0/3.0d0
      real :: four15ths=4.0d0/1.5d1
      real :: tiny=1.0d-20 !very small number, in case divide by zero
      real :: R_Bi=1.25d-1 !1/R_beta
      real :: R_ki=1.0d0/6.0d0 !1/R_k
      real :: R_oi=2.0d1/5.9d1 !1/R_omega
      real :: beta_st_inf=9.0d-2 !C_mu??
      real :: beta_i=7.2d-2 !other constants
      real :: alph_inf=5.2d-1
      real :: alph_0=1.0d0/9.0d0
      real :: alph_st_inf=1.0d0
      real f_beta,chi,Re_t,beta_st,alph,alph_st,alph_st_0
      parameter (prod_ratio=5.0d1)

      n=nx1*ny1*nz1*nelv

      alph_st_0=beta_i/3.0d0

      iclip_k=0
      ilim_k=0
      iclip_o=0
      ilim_o=0

      call gradm1(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),velu)
      call gradm1(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),velv)
      call gradm1(gradk(1,1),gradk(1,2),gradk(1,3),tke)
      call gradm1(grado(1,1),grado(1,2),grado(1,3),omega)

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),bm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),bm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),bm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),bm1)

      call opdssum(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3))
      call opdssum(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3))
      call opdssum(gradk(1,1),gradk(1,2),gradk(1,3))
      call opdssum(grado(1,1),grado(1,2),grado(1,3))

      call opcolv(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),binvm1)
      call opcolv(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),binvm1)
      call opcolv(gradk(1,1),gradk(1,2),gradk(1,3),binvm1)
      call opcolv(grado(1,1),grado(1,2),grado(1,3),binvm1)

      if(if3d) then
        call gradm1(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),velw)
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),bm1)
        call opdssum(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3))
        call opcolv(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),binvm1)
      endif

      do ipt=1,lxyz*nelv !for every point in the element

        if(tke(ipt).lt.0.0) then !limit on tke to keep it positive
          tke0=1.0d-2*abs(tke(ipt))
          tke(ipt)=tke0
          ilim_k=ilim_k+1
        else
          tke0=tke(ipt)
        endif

        if(omega(ipt).lt.0.0) then !limit on omega to keep it positive
          omega0=1.0d-2*abs(omega(ipt))
          omega(ipt)=omega0
          ilim_o=ilim_o+1
        else
          omega0=omega(ipt)
        endif

        if(iflomach) then
          rho=dens(ipt)
          mu=visc(ipt)
        else
          rho=dens(1)
          mu=visc(1)
        endif
        vistmax=5.0d3*mu

        Re_t=rho*tke0/(mu*omega0)
        alph_st=alph_st_inf*(alph_st_0+Re_t*R_ki)/(1.0d0+Re_t*R_ki)
        vist=rho*alph_st*tke0/omega0
        vist=min(vist,vistmax)
        mu_t(ipt)=vist !update eddy viscosity

cccccccccccccccccccccccccccccccccccccccccccccccccc
c   k source and sink terms (phi=k)
cccccccccccccccccccccccccccccccccccccccccccccccccc
        G_phi=0.0 !build the k source term
        do i=1,ldim !ignore terms in dimensions that don't exist
          do j=1,ldim
            tau_ij=vist*(gradu(ipt,i,j)+gradu(ipt,i,j))
            if(i.eq.j) tau_ij=tau_ij-twothirds*rho*tke0
            G_phi=G_phi+gradu(ipt,i,j)*tau_ij !don't bother with the squaring of the sqrt
          enddo
        enddo

        chi=0.0 !build the chi_k term
        do i=1,ldim
          chi=chi+gradk(ipt,i)*grado(ipt,i)
        enddo
        chi=chi/dmax1(omega0**3,tiny)

        if(chi.le.0) then !f_beta_star
          f_beta=1.0d0
        else
          f_beta=(1+6.80d2*chi**2)/(1+4.0d2*chi**2)
        endif

        beta_st=beta_st_inf*f_beta*((four15ths+(R_Bi*Re_t)**4)/
     &    (1.0d0+(R_Bi*Re_t)**4))

        Y_phi=rho*beta_st*tke0*omega0 !k sink term (dissipation of tke)

        src_t(ipt)=Y_phi !viscous dissipation term (turns tke into heat)

        if(G_phi.gt.prod_ratio*Y_phi) then !turbulence production clip
          iclip_k=iclip_k+1
          G_phi=prod_ratio*Y_phi
        endif

        src_k(ipt)=G_phi-Y_phi

cccccccccccccccccccccccccccccccccccccccccccccccccc
c   omega source and sink terms (phi=o)
cccccccccccccccccccccccccccccccccccccccccccccccccc
        alph=(alph_inf*(alph_0+Re_t*R_oi))/(alph_st*(1.0d0+Re_t*R_oi))

        G_phi=G_phi*omega0/tke0*alph !G_phi is already G_k from above

        chi=0.0 !build the chi_omega term
        if(if3d) then !Pope Correction for 2D flows
          do i=1,ldim
            do j=1,ldim
              O_ij=5.0d-1*(gradu(ipt,i,j)-gradu(ipt,j,i)) !vorticity
              do k=1,ldim
                O_jk=5.0d-1*(gradu(ipt,j,k)-gradu(ipt,k,j)) !vorticity
                S_ki=5.0d-1*(gradu(ipt,k,i)+gradu(ipt,i,k)) !strain
                chi=chi+O_ij*O_jk*S_ki
              enddo
            enddo
          enddo
          chi=abs(chi/max((beta_st_inf*omega0)**3,tiny))
        endif

        f_beta=(1.0d0+7.0d1*chi)/(1.0d0+8.0d1*chi)

        Y_phi=rho*beta_i*f_beta*omega0**2

        if(G_phi.gt.prod_ratio*Y_phi) then !omega production clip
          iclip_o=iclip_o+1
          G_phi=prod_ratio*Y_phi
        endif

        src_o(ipt)=G_phi-Y_phi

      enddo !1..ipt..n

      iclip_k=iglsum(iclip_k,1)
      ilim_k=iglsum(ilim_k,1)
      iclip_o=iglsum(iclip_o,1)
      ilim_o=iglsum(ilim_o,1)

      if((iclip_k+ilim_k+iclip_o+ilim_o).gt.0) then
        ifprint=.true.
      else
        ifprint=.false.
      endif

      if(nid.eq.0.and.ifprint) then
        if(iclip_k.gt.0)
     &    write(*,101) '  TKE production clipped on ',iclip_k,' points'
        if(ilim_k.gt.0)
     &    write(*,101) '  TKE limited on ',ilim_k,' points'
        if(iclip_o.gt.0)
     &    write(*,101) 'Omega production clipped on ',iclip_o,' points'
        if(ilim_o.gt.0)
     &    write(*,101) 'Omega limited on ',ilim_o,' points'
        write(*,*)
      endif

101    format(a32,i9,a)

      end
c-----------------------------------------------------------------------
